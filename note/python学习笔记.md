# python学习笔记

## 第一章 	计算机基础

### 1.1  主机显示

PS1="\e[31m[\u@\h \w]$\e[m"^C

## 第二章 	python入门

### 2,1 安装python

yum -y install python3

yum -y install pip3

yum -y install ipython3

## 第三章 	数据类型

### 3.1 类型

数字（整形	长整型	浮点数	复数）	字符串	列表	元组	字典	集合

```
#=============================基本使用====================================
#1、用途

#2、定义方式

#3、常用操作+内置的方法

#============================该类型总结==================================
#存一个值or存多个值
    
#有序or无序

#可变or不可变（1、可变：值变，id不变。可变==不可hash 2、不可变：值变，id就变。不可变==可hash）
```

#### 字符串

```
#作用：名字，性别，国籍，地址等描述信息

#定义：在单引号\双引号\三引号内，由一串字符组成
name='egon'

#优先掌握的操作：
#1、按索引取值(正向取+反向取) ：只能取
#2、切片(顾头不顾尾，步长)
#3、长度len
#4、成员运算in和not in

#5、移除空白strip
#6、切分split
#7、循环
```

#### 列表

```
#ps:反向步长
l=[1,2,3,4,5,6]

#正向步长
l[0:3:1] #[1, 2, 3]
#反向步长
l[2::-1] #[3, 2, 1]
#列表翻转
l[::-1] #[6, 5, 4, 3, 2, 1]
```

#### 元组

```
#作用：存多个值，对比列表来说，元组不可变（是可以当做字典的key的），主要是用来读

#定义：与列表类型比，只不过[]换成()
age=(11,22,33,44,55)本质age=tuple((11,22,33,44,55))

#优先掌握的操作：
#1、按索引取值(正向取+反向取)：只能取   
#2、切片(顾头不顾尾，步长)
#3、长度
#4、成员运算in和not in

#5、循环
```



#### 集合

```
#作用：去重，关系运算，

#定义：
            知识点回顾
            可变类型是不可hash类型
            不可变类型是可hash类型

#定义集合:
            集合：可以包含多个元素，用逗号分割，
            集合的元素遵循三个原则：
             1：每个元素必须是不可变类型(可hash，可作为字典的key)
             2:没有重复的元素
             3：无序

注意集合的目的是将不同的值存放到一起，不同的集合间用来做关系运算，无需纠结于集合中单个值
 

#优先掌握的操作：
#1、长度len
#2、成员运算in和not in

#3、|合集
#4、&交集
#5、-差集
#6、^对称差集
#7、==
#8、父集：>,>= #9、子集：<,<=  
```



#### 数据类型总结（存储空间占用从低到高）

```
数字
字符串
集合：无序，即无序存索引相关信息
元组：有序，需要存索引相关信息，不可变
列表：有序，需要存索引相关信息，可变，需要处理数据的增删改
字典：无序，需要存key与value映射的相关信息，可变，需要处理数据的增删改
```

## 第四章 	文件操作

### 4.1流程

```
#1. 打开文件，得到文件句柄并赋值给一个变量
#2. 通过句柄对文件进行操作
#3. 关闭文件

#1. 打开文件，得到文件句柄并赋值给一个变量
f=open('a.txt','r',encoding='utf-8') #默认打开模式就为r

#2. 通过句柄对文件进行操作
data=f.read()

#3. 关闭文件
f.close()
```

### 4.2模式

```
#1. 打开文件的模式有(默认为文本模式)：
r ，只读模式【默认模式，文件必须存在，不存在则抛出异常】
w，只写模式【不可读；不存在则创建；存在则清空内容】
a， 之追加写模式【不可读；不存在则创建；存在则只追加内容】

#2. 对于非文本文件，我们只能使用b模式，"b"表示以字节的方式操作（而所有文件也都是以字节的形式存储的，使用这种模式无需考虑文本文件的字符编码、图片文件的jgp格式、视频文件的avi格式）
rb 
wb
ab
注：以b方式打开时，读取到的内容是字节类型，写入时也需要提供字节类型，不能指定编码

#3. 了解部分
"+" 表示可以同时读写某个文件
r+， 读写【可读，可写】
w+，写读【可读，可写】
a+， 写读【可读，可写】


x， 只写模式【不可读；不存在则创建，存在则报错】
x+ ，写读【可读，可写】
xb
```

### 4.3文件修改

```
import os

with open('a.txt') as read_f,open('.a.txt.swap','w') as write_f:
    for line in read_f:
        line=line.replace('alex','SB')
        write_f.write(line)

os.remove('a.txt')
os.rename('.a.txt.swap','a.txt') 
```



## 第五章 	函数

### 5.1 函数知识体系

```
1 什么是函数？
2 为什么要用函数？
3 函数的分类：内置函数与自定义函数
4 如何自定义函数
  语法
  定义有参数函数，及有参函数的应用场景
  定义无参数函数，及无参函数的应用场景
  定义空函数，及空函数的应用场景

5 调用函数
    如何调用函数
    函数的返回值
    函数参数的应用：形参和实参，位置参数，关键字参数，默认参数，*args，**kwargs

6 高阶函数（函数对象）
7 函数嵌套
8 作用域与名称空间
9 装饰器
10 迭代器与生成器及协程函数
11 三元运算，列表解析、生成器表达式
12 函数的递归调用
13 内置函数
14 面向过程编程与函数式编程
```

```
#1、位置参数：按照从左到右的顺序定义的参数
        位置形参：必选参数
        位置实参：按照位置给形参传值

#2、关键字参数：按照key=value的形式定义的实参
        无需按照位置为形参传值
        注意的问题：
                1. 关键字实参必须在位置实参右面
                2. 对同一个形参不能重复传值

#3、默认参数：形参在定义时就已经为其赋值
        可以传值也可以不传值，经常需要变得参数定义成位置形参，变化较小的参数定义成默认参数（形参）
        注意的问题：
                1. 只在定义时赋值一次
                2. 默认参数的定义应该在位置形参右面
                3. 默认参数通常应该定义成不可变类型


#4、可变长参数：
        可变长指的是实参值的个数不固定
        而实参有按位置和按关键字两种形式定义，针对这两种形式的可变长，形参对应有两种解决方案来完整地存放它们，分别是*args，**kwargs

        ===========*args===========
        def foo(x,y,*args):
            print(x,y)
            print(args)
        foo(1,2,3,4,5)

        def foo(x,y,*args):
            print(x,y)
            print(args)
        foo(1,2,*[3,4,5])


        def foo(x,y,z):
            print(x,y,z)
        foo(*[1,2,3])

        ===========**kwargs===========
        def foo(x,y,**kwargs):
            print(x,y)
            print(kwargs)
        foo(1,y=2,a=1,b=2,c=3)

        def foo(x,y,**kwargs):
            print(x,y)
            print(kwargs)
        foo(1,y=2,**{'a':1,'b':2,'c':3})


        def foo(x,y,z):
            print(x,y,z)
        foo(**{'z':1,'x':2,'y':3})

        ===========*args+**kwargs===========

        def foo(x,y):
            print(x,y)

        def wrapper(*args,**kwargs):
            print('====>')
            foo(*args,**kwargs)

#5、命名关键字参数：*后定义的参数，必须被传值（有默认值的除外），且必须按照关键字实参的形式传递
可以保证，传入的参数中一定包含某些关键字
        def foo(x,y,*args,a=1,b,**kwargs):
            print(x,y)
            print(args)
            print(a)
            print(b)
            print(kwargs)

        foo(1,2,3,4,5,b=3,c=4,d=5)
        结果：
            1
            2
            (3, 4, 5)
            1
            3
            {'c': 4, 'd': 5}
```

```
什么时候该有返回值？
　　　　调用函数，经过一系列的操作，最后要拿到一个明确的结果，则必须要有返回值
　　　　通常有参函数需要有返回值，输入参数，经过计算，得到一个最终的结果
什么时候不需要有返回值？
　　　　调用函数，仅仅只是执行一系列的操作，最后不需要得到什么结果，则无需有返回值
　　　　通常无参函数不需要有返回值
```

### 5.2函数对象、函数嵌套、名称空间与作用域、装饰器

函数对象

```
#1 可以被引用
#2 可以当作参数传递
#3 返回值可以是函数
#3 可以当作容器类型的元素
```

嵌套

```
def f1():
    def f2():
        def f3():
            print('from f3')
        f3()
    f2()

f1()
f3() #报错，为何？请看下一小节
```

一 名称空间

```
名称空间：存放名字的地方，三种名称空间
```

**二 名称空间的加载顺序**

```
python test.py
#1、python解释器先启动，因而首先加载的是：内置名称空间
#2、执行test.py文件，然后以文件为基础，加载全局名称空间
#3、在执行文件的过程中如果调用函数，则临时产生局部名称空间
```

三 名字的查找顺序

```
局部名称空间--->全局名称空间--->内置名称空间

#需要注意的是：在全局无法查看局部的，在局部可以查看全局的，如下示例

# max=1
def f1():
    # max=2
    def f2():
        # max=3
        print(max)
    f2()
f1()
print(max) 
```

四作用域

```
#1、作用域即范围
        - 全局范围（内置名称空间与全局名称空间属于该范围）：全局存活，全局有效
　     - 局部范围（局部名称空间属于该范围）：临时存活，局部有效
#2、作用域关系是在函数定义阶段就已经固定的，与函数的调用位置无关，如下
x=1
def f1():
    def f2():
        print(x)
    return f2
x=100
def f3(func):
    x=2
    func()
x=10000
f3(f1())

#3、查看作用域：globals(),locals()


LEGB 代表名字查找顺序: locals -> enclosing function -> globals -> __builtins__
locals 是函数内的名字空间，包括局部变量和形参
enclosing 外部嵌套函数的名字空间（闭包中常见）
globals 全局变量，函数定义所在模块的名字空间
builtins 内置模块的名字空间
```

### 5.3闭包

```
#内部函数包含对外部作用域而非全局作用域的引用

#提示：之前我们都是通过参数将外部的值传给函数，闭包提供了另外一种思路，包起来喽，包起呦，包起来哇

        def counter():
            n=0
            def incr():
                nonlocal n
                x=n
                n+=1
                return x
            return incr

        c=counter()
        print(c())
        print(c())
        print(c())
        print(c.__closure__[0].cell_contents) #查看闭包的元素
```

二 闭包的意义与应用

```
#闭包的意义：返回的函数对象，不仅仅是一个函数对象，在该函数外还包裹了一层作用域，这使得，该函数无论在何处调用，优先使用自己外层包裹的作用域
#应用领域：延迟计算（原来我们是传参，现在我们是包起来）
    from urllib.request import urlopen

    def index(url):
        def get():
            return urlopen(url).read()
        return get

    baidu=index('http://www.baidu.com')
    print(baidu().decode('utf-8'))
```

### 5.4装饰器

装饰器就是闭包函数的一种应用场景

**一 为何要用装饰器**

```
#开放封闭原则：对修改封闭，对扩展开放
```

**二 什么是装饰器**

```
装饰器他人的器具，本身可以是任意可调用对象，被装饰者也可以是任意可调用对象。
强调装饰器的原则：1 不修改被装饰对象的源代码 2 不修改被装饰对象的调用方式
装饰器的目标：在遵循1和2的前提下，为被装饰对象添加上新功能
```

### 5.5三元表达式、生成器表达式、匿名函数、内置函数

**一 三元表达式**

```
name=input('姓名>>: ')
res='SB' if name == 'alex' else 'NB'
print(res)
```

二 生成器表达式

```
#1、把列表推导式的[]换成()就是生成器表达式

#2、示例：生一筐鸡蛋变成给你一只老母鸡，用的时候就下蛋，这也是生成器的特性
>>> chicken=('鸡蛋%s' %i for i in range(5))
>>> chicken
<generator object <genexpr> at 0x10143f200>
>>> next(chicken)
'鸡蛋0'
>>> list(chicken) #因chicken可迭代，因而可以转成列表
['鸡蛋1', '鸡蛋2', '鸡蛋3', '鸡蛋4',]

#3、优点：省内存，一次只产生一个值在内存中
```

三匿名函数

一 什么是匿名函数

```
匿名就是没有名字
def func(x,y,z=1):
    return x+y+z

匿名
lambda x,y,z=1:x+y+z #与函数有相同的作用域，但是匿名意味着引用计数为0，使用一次就释放，除非让其有名字
func=lambda x,y,z=1:x+y+z 
func(1,2,3)
#让其有名字就没有意义
```

**二 有名字的函数与匿名函数的对比**

```
#有名函数与匿名函数的对比
有名函数：循环使用，保存了名字，通过名字就可以重复引用函数功能

匿名函数：一次性使用，随时随时定义

应用：max，min，sorted,map,reduce,filter
```





## 第六章	 模块

### **1、什么是模块？**

![img](https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif)

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
大家之前在编写ATM作业时，思路是先将程序中都需要有哪些功能定义出来，然后在需要用的地方调用即可。
比起之前通篇垒代码的方式，将重复要用的功能定义成函数会让程序更加简洁，这不能不算做是一种进步，
但问题是，随着程序功能越来越多，再将所有的代码都放到一起，程序的组织结构仍然会不清晰，不方便管理，
以后我们写程序，都是分文件的，如果多个文件中都需要用到同一段功能，难道我们要重复编写该功能吗？很明显不能
这就需要我们找到一种解决方案，能够将程序中经常要用的功能集合到一起，然后在想用的地方随时导入使用，
这几乎就是模块的全部含义了

最后总结：
模块就是一组功能的集合体，我们的程序可以导入模块来复用模块里的功能。
```

```
#常见的场景：一个模块就是一个包含了一组功能的python文件,比如spam.py，模块名为spam，可以通过import spam使用。

#在python中，模块的使用方式都是一样的，但其实细说的话，模块可以分为四个通用类别：　

　　1 使用python编写的.py文件

　　2 已被编译为共享库或DLL的C或C++扩展

　　3 把一系列模块组织到一起的文件夹（注：文件夹下有一个__init__.py文件，该文件夹称之为包）

　　4 使用C编写并链接到python解释器的内置模块
```

2、为何要使用模块

```
#1、从文件级别组织程序，更方便管理
随着程序的发展，功能越来越多，为了方便管理，我们通常将程序分成一个个的文件，这样做程序的结构更清晰，方便管理。这时我们不仅仅可以把这些文件当做脚本去执行，还可以把他们当做模块来导入到其他的模块中，实现了功能的重复利用

#2、拿来主义，提升开发效率
同样的原理，我们也可以下载别人写好的模块然后导入到自己的项目中使用，这种拿来主义，可以极大地提升我们的开发效率

#ps：
如果你退出python解释器然后重新进入，那么你之前定义的函数或者变量都将丢失，因此我们通常将程序写到文件中以便永久保存下来，需要时就通过python test.py方式去执行，此时test.py被称为脚本script。
```

**为模块名起别名**

为已经导入的模块起别名的方式对编写可扩展的代码很有用

```
1 import spam as sm
2 print(sm.money)
```



### 1、from...import...的使用

```
 1 from spam import read1,read2
 
 唯一的区别就是：使用from...import...则是将spam中的名字直接导入到当前的名称空间中，所以在当前名称空间中，直接使用名字就可以了、无需加前缀：spam.
```



### py文件区分两种用途:模块与脚本

```
#编写好的一个python文件可以有两种用途：
    一：脚本，一个文件就是整个程序，用来被执行
    二：模块，文件中存放着一堆功能，用来被导入使用


#python为我们内置了全局变量__name__，
    当文件被当做脚本执行时：__name__ 等于'__main__'
    当文件被当做模块导入时：__name__等于模块名

#作用：用来控制.py文件在不同的应用场景下执行不同的逻辑
    if __name__ == '__main__':
```











## 第七章 	面向对象

## 第八章 	网络编程

## 第九章 	并发编程

## 第十章  	数据库

## 第十一章 前端开发

## 第十二章	Django框架





